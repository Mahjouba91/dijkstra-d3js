<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<title>Algorithme de Dijkstra</title>
<style>
html, body, #graph {
    width: 1200px;
    height: 650px;
}
</style>
</head>

<body>
<div id="graph"></div>    
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
!(function(){
    "use strict"

    var width,height
    var chartWidth, chartHeight
    var margin
    var svg = d3.select("#graph").append("svg")
    var chartLayer = svg.append("g").classed("chartLayer", true)
    
    main()

    function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min +1)) + min;
    }
    
    function main() {
        var nb_nodes = getRandomIntInclusive(10, 40)
        var data = {
            nodes:d3.range( 0, nb_nodes ).map(function(d){ 
              return {
                label: "N"+d, 
                r:20
              }
            }),
            links: {}
            // d3.range(0, getRandomIntInclusive(1, 8) * nb_nodes).map(function(){ 
            //   return {
            //     source:~~d3.randomUniform(nb_nodes)(), 
            //     target:~~d3.randomUniform(nb_nodes)(),
            //     distance: getRandomIntInclusive(1, 9)
            //   } 
            // })        
        }

        var jsonArr = [];
        for (var i = 0; i < nb_nodes; i++) {
            var nb_links = getRandomIntInclusive(1, 8)
            if ( i + 9 >= nb_nodes) {
                nb_links = ( nb_nodes - i ) - 1
            }
            for (var j = 1; j <= nb_links; j++) {
                jsonArr.push({
                    source: data.nodes[i], 
                    target: data.nodes[j+i],
                    distance: getRandomIntInclusive(1, 9)
                });
            }
        }
        data.links = jsonArr;

        console.log( data );
        
        setSize(data)
        drawChart(data)    
    }
    
    function setSize(data) {
        width = document.querySelector("#graph").clientWidth
        height = document.querySelector("#graph").clientHeight
    
        margin = {top:0, left:0, bottom:0, right:0 }
        
        chartWidth = width - (margin.left+margin.right)
        chartHeight = height - (margin.top+margin.bottom)
        
        svg.attr("width", width).attr("height", height)
        
        chartLayer
            .attr("width", chartWidth)
            .attr("height", chartHeight)
            .attr("transform", "translate("+[margin.left, margin.top]+")")
    }
    
    function drawChart(data) {
        
        var simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(function(d) { return d.index }))
            .force("collide",d3.forceCollide( function(d){return d.r + 32 }).iterations(64) )
            .force("charge", d3.forceManyBody())
            .force("center", d3.forceCenter(chartWidth / 2, chartHeight / 2))
            .force("y", d3.forceY(0))
            .force("x", d3.forceX(0))
    
        var link = svg.append("g")
            .attr("class", "links")
            .selectAll("line")
            .data(data.links)
            .enter()
            .append("line")
            .attr("stroke", "black")

        var node = svg.append("g")
            .attr("class", "nodes")
            .selectAll("circle")
            .data(data.nodes)
            .enter().append("circle")
            .attr("r", function(d){  return d.r })
            .attr("fill", "#34495e")
            .attr("stroke", "#000")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // console.log(document.querySelectorAll('.nodes circle'));
        // document.querySelectorAll('.nodes circle').onmouseover = function( event ){
        //     console.log('Hello');
        //     console.log(event);
        //     console.log(elem);
        // }

        var node_label = svg.append("g")
            .attr("class", "node_labels")
            .selectAll("text")
            .data(data.nodes)
            .enter()
            .append("text")
            .text( function (d) { return d.label; })
            .attr("font-family", "Arial")
            .attr("font-size", "14px")
            .attr("text-anchor", "middle")
            .attr("dy", ".35em")
            .attr("fill", "white") 

        var link_distance = svg.append("g")
            .attr("class", "link_distance")
            .selectAll("text")
            .data(data.links)
            .enter()
            .append("text")
            .text( function (d) { return d.distance; })
            .attr("font-family", "Arial")
            .attr("font-size", "14px")
            .attr("text-anchor", "middle")
            .attr("dy", ".35em")
            .attr("fill", "#000") 

        var ticked = function() {
            link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });
    
            node
                .attr("cx", function(d) { return d.x; })
                .attr("cy", function(d) { return d.y; });

            node_label
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y; });

            link_distance
                .attr("x", function(d) { return d.source.x + ( (d.target.x - d.source.x) / 2 ); })
                .attr("y", function(d) { return d.source.y + ( (d.target.y - d.source.y) / 2 ) - 10; });
        }  
        
        simulation
            .nodes(data.nodes)
            .on("tick", ticked);
    
        simulation.force("link")
            .links(data.links);
        
        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }
        
        function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }         

    }

    var showDetails = function(d, i) {
        var content;
        content = '<p class="main">' + d.name + '</span></p>';
        content += '<hr class="tooltip-hr">';
        content += '<p class="main">' + d.artist + '</span></p>';
        tooltip.showTooltip(content, d3.event);
        if (link) {
          link.attr("stroke", function(l) {
            if (l.source === d || l.target === d) {
              return "#555";
            } else {
              return "#ddd";
            }
          }).attr("stroke-opacity", function(l) {
            if (l.source === d || l.target === d) {
              return 1.0;
            } else {
              return 0.5;
            }
          });
        }
        node.style("stroke", function(n) {
          if (n.searched || neighboring(d, n)) {
            return "#555";
          } else {
            return strokeFor(n);
          }
        }).style("stroke-width", function(n) {
          if (n.searched || neighboring(d, n)) {
            return 2.0;
          } else {
            return 1.0;
          }
        });
        return d3.select(this).style("stroke", "black").style("stroke-width", 2.0);
    };

}());
</script>    
</body>
</html>
